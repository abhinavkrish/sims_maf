# Filling out what should be in a config file for a MAF driver

# Database access 
dbAddress = 'mysql://lsst:lsst@blahblah/'

# output location
outputDir = 'path/to/somwhere'

# Which opsim runs should be analyzed
opsimNames = ['opsim_3_61', 'opsim_happyrun', 'opsim_sadrun']

# Comparison run.  Compare each opsim run to this one.  There is a motion to kill this line and leave comparisons to later.
compareToName = 'opsim_3_61'

#Any constraints to be put on the database query
DBconstraints = ['night < 730', 'night < 1825', ' ']  # pull 2-years, 5-years, and all data.

# Constraints to loop over 
constraints = itertools.product(['filter == '+s+' & ' for s in ['"u"','"g"','"r"','"i"','"z"','"y"']], ['proposalID == ' + s+' & ' for s in ['"WFD"', '"other"']], ['seeing ' +s for s in ['< 0.5','>=0.5']]+ [' '] )

# Grids to use and the metrics to run on them
grid1 = grids.GlobalGrid
metricsForGrid1 = [metrics.MeanMetric('5sigma_modified'),  metrics.RmsMetric('seeing'), metrics.MaxMetric('5sigma_modified')]
constraintsForGrid1 = constraints

grid2 = grids.HealpixGrid
metricsForGrid2 = [metrics.Coaddm5Metric('5sigma_modified')]
constraintsForGrid2 = constraints

# Run another healpix grid, but now with different constraints
grid3 = grids.HealpixGrid
metricsForGrid3 = [metrics.properMotionMetric(), metrics.parallaxMetric()]
constraintsForGrid3 = ' | '.join(['(filter == ' + s +')' for s in ['g','r','i']])

grid4 = grids.userSpatialGrid('grid.dat')
metricsForGrid4 = []


#The general flow of the driver:
# instantiate the grids and metrics
# use the classRegistry to figure out what to pull from the database
# so the driver:
# Loops over a product of opsimNames and DBconstraints:
#    Pulls data from DB (driver might need to know about different columns and if there need to be different data objects, say for science and engineering since they might be different sizes.)
#    Loop over each grid
#         Loop over each constraint
#              instantiate a gridMetric
#              Run gridMetric with data[sliced by constraint] and metriclist_forgrid_i
#              gridMetric then loops over each metric
#                 metric calculates a thing!
#              gridmetric writes output and plots

#Do we want to push the constraint loop to inside the gridMetric?  Don't think it matters for global metrics, but not sure which is better for spatial metrics.  To do:  test speed difference between searching two small kd-trees versus one big kd-tree.--speed test says it's a little faster to run two small trees rather than one big tree.  Does this mean all slicing should just be done at the DB-level?  That would make things super simple since then we don't have to mix sql and numpy.where constraints.

#the itertools.product is getting close, but right now it's just a string.  Is there an easy way to convert that to code, or does it need to be parsed later on?


# I like this itertools thing.  It would make it really easy to generate the frames for a movie!
